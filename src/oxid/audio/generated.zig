// THIS FILE WAS GENERATED BY THE ZANGC COMPILER

const std = @import("std");
const zang = @import("zang");

const _curve_laser_curve = [_]zang.CurveNode{
    .{ .t = 0.0, .value = 1000.0 },
    .{ .t = 0.1, .value = 200.0 },
    .{ .t = 0.2, .value = 100.0 },
};

const _curve_laser_volume = [_]zang.CurveNode{
    .{ .t = 0.0, .value = 0.0 },
    .{ .t = 0.004, .value = 0.35 },
    .{ .t = 0.2, .value = 0.0 },
};

const _curve_explosion_cutoff = [_]zang.CurveNode{
    .{ .t = 0.0, .value = 3000.0 },
    .{ .t = 0.5, .value = 1000.0 },
    .{ .t = 0.7, .value = 200.0 },
};

const _curve_explosion_volume = [_]zang.CurveNode{
    .{ .t = 0.0, .value = 0.0 },
    .{ .t = 0.004, .value = 0.75 },
    .{ .t = 0.7, .value = 0.0 },
};

const _track_menu_blip = struct {
    const Params = struct {
        freq: f32,
        note_on: bool,
    };
    const notes = [_]zang.Notes(Params).SongEvent{
        .{ .t = 0.00, .note_id = 1, .params = .{ .freq = 60.0, .note_on = true } },
        .{ .t = 0.02, .note_id = 2, .params = .{ .freq = 60.0, .note_on = false } },
        .{ .t = 0.08, .note_id = 3, .params = .{ .freq = 40.0, .note_on = true } },
        .{ .t = 0.10, .note_id = 4, .params = .{ .freq = 40.0, .note_on = false } },
    };
};

const _track_menu_ding = struct {
    const Params = struct {
        freq: f32,
        note_on: bool,
    };
    const notes = [_]zang.Notes(Params).SongEvent{
        .{ .t = 0.00, .note_id = 1, .params = .{ .freq = 80.0, .note_on = true } },
        .{ .t = 0.01, .note_id = 2, .params = .{ .freq = 60.0, .note_on = true } },
        .{ .t = 0.02, .note_id = 3, .params = .{ .freq = 70.0, .note_on = true } },
        .{ .t = 0.03, .note_id = 4, .params = .{ .freq = 50.0, .note_on = true } },
        .{ .t = 0.04, .note_id = 5, .params = .{ .freq = 60.0, .note_on = true } },
        .{ .t = 0.05, .note_id = 6, .params = .{ .freq = 40.0, .note_on = true } },
        .{ .t = 0.06, .note_id = 7, .params = .{ .freq = 50.0, .note_on = true } },
        .{ .t = 0.07, .note_id = 8, .params = .{ .freq = 30.0, .note_on = true } },
        .{ .t = 0.08, .note_id = 9, .params = .{ .freq = 40.0, .note_on = true } },
        .{ .t = 0.09, .note_id = 10, .params = .{ .freq = 20.0, .note_on = true } },
        .{ .t = 0.10, .note_id = 11, .params = .{ .freq = 30.0, .note_on = false } },
    };
};

const _track_menu_backoff = struct {
    const Params = struct {
        freq: f32,
        note_on: bool,
    };
    const notes = [_]zang.Notes(Params).SongEvent{
        .{ .t = 0.00, .note_id = 1, .params = .{ .freq = 70.0, .note_on = true } },
        .{ .t = 0.01, .note_id = 2, .params = .{ .freq = 75.0, .note_on = true } },
        .{ .t = 0.02, .note_id = 3, .params = .{ .freq = 80.0, .note_on = true } },
        .{ .t = 0.03, .note_id = 4, .params = .{ .freq = 85.0, .note_on = true } },
        .{ .t = 0.04, .note_id = 5, .params = .{ .freq = 90.0, .note_on = true } },
        .{ .t = 0.05, .note_id = 6, .params = .{ .freq = 95.0, .note_on = true } },
        .{ .t = 0.06, .note_id = 7, .params = .{ .freq = 100.0, .note_on = true } },
        .{ .t = 0.07, .note_id = 8, .params = .{ .freq = 105.0, .note_on = false } },
    };
};

const _track_wave_begin = struct {
    const Params = struct {
        freq: f32,
        note_on: bool,
    };
    const notes = [_]zang.Notes(Params).SongEvent{
        .{ .t = 0.0, .note_id = 1, .params = .{ .freq = 40.0, .note_on = true } },
        .{ .t = 1.0, .note_id = 2, .params = .{ .freq = 43.0, .note_on = true } },
        .{ .t = 2.0, .note_id = 3, .params = .{ .freq = 36.0, .note_on = true } },
        .{ .t = 3.0, .note_id = 4, .params = .{ .freq = 45.0, .note_on = true } },
        .{ .t = 4.0, .note_id = 5, .params = .{ .freq = 43.0, .note_on = true } },
        .{ .t = 5.0, .note_id = 6, .params = .{ .freq = 36.0, .note_on = true } },
        .{ .t = 6.0, .note_id = 7, .params = .{ .freq = 40.0, .note_on = true } },
        .{ .t = 7.0, .note_id = 8, .params = .{ .freq = 45.0, .note_on = true } },
        .{ .t = 8.0, .note_id = 9, .params = .{ .freq = 43.0, .note_on = true } },
        .{ .t = 9.0, .note_id = 10, .params = .{ .freq = 35.0, .note_on = true } },
        .{ .t = 10.0, .note_id = 11, .params = .{ .freq = 38.0, .note_on = true } },
        .{ .t = 11.0, .note_id = 12, .params = .{ .freq = 38.0, .note_on = false } },
    };
};

const _track_accelerate = struct {
    const Params = struct {
        freq: f32,
        note_on: bool,
    };
    const notes = [_]zang.Notes(Params).SongEvent{
        .{ .t = 0.0, .note_id = 1, .params = .{ .freq = 43.0, .note_on = true } },
        .{ .t = 1.0, .note_id = 2, .params = .{ .freq = 36.0, .note_on = true } },
        .{ .t = 2.0, .note_id = 3, .params = .{ .freq = 40.0, .note_on = true } },
        .{ .t = 3.0, .note_id = 4, .params = .{ .freq = 45.0, .note_on = true } },
        .{ .t = 4.0, .note_id = 5, .params = .{ .freq = 43.0, .note_on = true } },
        .{ .t = 5.0, .note_id = 6, .params = .{ .freq = 35.0, .note_on = true } },
        .{ .t = 6.0, .note_id = 7, .params = .{ .freq = 38.0, .note_on = true } },
        .{ .t = 7.0, .note_id = 8, .params = .{ .freq = 38.0, .note_on = false } },
    };
};

const _track_coin = struct {
    const Params = struct {
        freq: f32,
        note_on: bool,
    };
    const notes = [_]zang.Notes(Params).SongEvent{
        .{ .t = 0.000, .note_id = 1, .params = .{ .freq = 750.0, .note_on = true } },
        .{ .t = 0.045, .note_id = 2, .params = .{ .freq = 1000.0, .note_on = true } },
        .{ .t = 0.090, .note_id = 3, .params = .{ .freq = 1000.0, .note_on = false } },
    };
};

pub const MenuInstrument = struct {
    pub const num_outputs = 1;
    pub const num_temps = 3;
    pub const Params = struct {
        sample_rate: f32,
        freq: f32,
        note_on: bool,
    };
    pub const NoteParams = struct {
        freq: f32,
        note_on: bool,
    };

    field0_PulseOsc: zang.PulseOsc,
    field1_Envelope: zang.Envelope,
    field2_Filter: zang.Filter,

    pub fn init() MenuInstrument {
        return .{
            .field0_PulseOsc = zang.PulseOsc.init(),
            .field1_Envelope = zang.Envelope.init(),
            .field2_Filter = zang.Filter.init(),
        };
    }

    pub fn paint(self: *MenuInstrument, span: zang.Span, outputs: [num_outputs][]f32, temps: [num_temps][]f32, note_id_changed: bool, params: Params) void {
        zang.zero(span, temps[0]);
        self.field0_PulseOsc.paint(span, .{temps[0]}, .{}, note_id_changed, .{
            .sample_rate = params.sample_rate,
            .freq = zang.constant(params.freq),
            .color = 0.5,
        });
        zang.zero(span, temps[1]);
        self.field1_Envelope.paint(span, .{temps[1]}, .{}, note_id_changed, .{
            .sample_rate = params.sample_rate,
            .attack = .instantaneous,
            .decay = .instantaneous,
            .release = .{ .linear = 0.04 },
            .sustain_volume = 1.0,
            .note_on = params.note_on,
        });
        zang.zero(span, temps[2]);
        zang.multiplyScalar(span, temps[2], temps[1], 0.25);
        zang.zero(span, temps[1]);
        zang.multiply(span, temps[1], temps[0], temps[2]);
        const temp_float0 = std.math.pi * 2000.0;
        const temp_float1 = temp_float0 / params.sample_rate;
        const temp_float2 = std.math.cos(temp_float1);
        const temp_float3 = 1.0 - temp_float2;
        const temp_float4 = 2.0 * temp_float3;
        const temp_float5 = std.math.min(1.0, temp_float4);
        const temp_float6 = std.math.max(0.0, temp_float5);
        const temp_float7 = std.math.sqrt(temp_float6);
        self.field2_Filter.paint(span, .{outputs[0]}, .{}, note_id_changed, .{
            .input = temps[1],
            .type = .low_pass,
            .cutoff = zang.constant(temp_float7),
            .res = 0.3,
        });
    }
};

pub const MenuBlipVoice = struct {
    pub const num_outputs = 1;
    pub const num_temps = 3;
    pub const Params = struct {
        sample_rate: f32,
        freq_mul: f32,
    };
    pub const NoteParams = struct {
        freq_mul: f32,
    };

    field0_MenuInstrument: MenuInstrument,
    tracker0: zang.Notes(_track_menu_blip.Params).NoteTracker,
    trigger0: zang.Trigger(_track_menu_blip.Params),

    pub fn init() MenuBlipVoice {
        return .{
            .field0_MenuInstrument = MenuInstrument.init(),
            .tracker0 = zang.Notes(_track_menu_blip.Params).NoteTracker.init(&_track_menu_blip.notes),
            .trigger0 = zang.Trigger(_track_menu_blip.Params).init(),
        };
    }

    pub fn paint(self: *MenuBlipVoice, span: zang.Span, outputs: [num_outputs][]f32, temps: [num_temps][]f32, note_id_changed: bool, params: Params) void {
        if (note_id_changed) {
            self.tracker0.reset();
            self.trigger0.reset();
        }
        const _iap0 = self.tracker0.consume(params.sample_rate / 1.0, span.end - span.start);
        var _ctr0 = self.trigger0.counter(span, _iap0);
        while (self.trigger0.next(&_ctr0)) |_result| {
            const _new_note = note_id_changed or _result.note_id_changed;
            const temp_float0 = params.freq_mul * _result.params.freq;
            self.field0_MenuInstrument.paint(_result.span, .{outputs[0]}, .{temps[0], temps[1], temps[2]}, _new_note, .{
                .sample_rate = params.sample_rate,
                .freq = temp_float0,
                .note_on = _result.params.note_on,
            });
        }
    }
};

pub const MenuDingVoice = struct {
    pub const num_outputs = 1;
    pub const num_temps = 3;
    pub const Params = struct {
        sample_rate: f32,
    };
    pub const NoteParams = struct {
    };

    field0_MenuInstrument: MenuInstrument,
    tracker0: zang.Notes(_track_menu_ding.Params).NoteTracker,
    trigger0: zang.Trigger(_track_menu_ding.Params),

    pub fn init() MenuDingVoice {
        return .{
            .field0_MenuInstrument = MenuInstrument.init(),
            .tracker0 = zang.Notes(_track_menu_ding.Params).NoteTracker.init(&_track_menu_ding.notes),
            .trigger0 = zang.Trigger(_track_menu_ding.Params).init(),
        };
    }

    pub fn paint(self: *MenuDingVoice, span: zang.Span, outputs: [num_outputs][]f32, temps: [num_temps][]f32, note_id_changed: bool, params: Params) void {
        if (note_id_changed) {
            self.tracker0.reset();
            self.trigger0.reset();
        }
        const _iap0 = self.tracker0.consume(params.sample_rate / 0.8, span.end - span.start);
        var _ctr0 = self.trigger0.counter(span, _iap0);
        while (self.trigger0.next(&_ctr0)) |_result| {
            const _new_note = note_id_changed or _result.note_id_changed;
            self.field0_MenuInstrument.paint(_result.span, .{outputs[0]}, .{temps[0], temps[1], temps[2]}, _new_note, .{
                .sample_rate = params.sample_rate,
                .freq = _result.params.freq,
                .note_on = _result.params.note_on,
            });
        }
    }
};

pub const MenuBackoffVoice = struct {
    pub const num_outputs = 1;
    pub const num_temps = 3;
    pub const Params = struct {
        sample_rate: f32,
    };
    pub const NoteParams = struct {
    };

    field0_MenuInstrument: MenuInstrument,
    tracker0: zang.Notes(_track_menu_backoff.Params).NoteTracker,
    trigger0: zang.Trigger(_track_menu_backoff.Params),

    pub fn init() MenuBackoffVoice {
        return .{
            .field0_MenuInstrument = MenuInstrument.init(),
            .tracker0 = zang.Notes(_track_menu_backoff.Params).NoteTracker.init(&_track_menu_backoff.notes),
            .trigger0 = zang.Trigger(_track_menu_backoff.Params).init(),
        };
    }

    pub fn paint(self: *MenuBackoffVoice, span: zang.Span, outputs: [num_outputs][]f32, temps: [num_temps][]f32, note_id_changed: bool, params: Params) void {
        if (note_id_changed) {
            self.tracker0.reset();
            self.trigger0.reset();
        }
        const _iap0 = self.tracker0.consume(params.sample_rate / 0.8, span.end - span.start);
        var _ctr0 = self.trigger0.counter(span, _iap0);
        while (self.trigger0.next(&_ctr0)) |_result| {
            const _new_note = note_id_changed or _result.note_id_changed;
            self.field0_MenuInstrument.paint(_result.span, .{outputs[0]}, .{temps[0], temps[1], temps[2]}, _new_note, .{
                .sample_rate = params.sample_rate,
                .freq = _result.params.freq,
                .note_on = _result.params.note_on,
            });
        }
    }
};

pub const WaveBeginInstrument = struct {
    pub const num_outputs = 1;
    pub const num_temps = 3;
    pub const Params = struct {
        sample_rate: f32,
        freq: f32,
        note_on: bool,
    };
    pub const NoteParams = struct {
        freq: f32,
        note_on: bool,
    };

    field0_PulseOsc: zang.PulseOsc,
    field1_Envelope: zang.Envelope,

    pub fn init() WaveBeginInstrument {
        return .{
            .field0_PulseOsc = zang.PulseOsc.init(),
            .field1_Envelope = zang.Envelope.init(),
        };
    }

    pub fn paint(self: *WaveBeginInstrument, span: zang.Span, outputs: [num_outputs][]f32, temps: [num_temps][]f32, note_id_changed: bool, params: Params) void {
        zang.zero(span, temps[0]);
        self.field0_PulseOsc.paint(span, .{temps[0]}, .{}, note_id_changed, .{
            .sample_rate = params.sample_rate,
            .freq = zang.constant(params.freq),
            .color = 0.5,
        });
        zang.zero(span, temps[1]);
        self.field1_Envelope.paint(span, .{temps[1]}, .{}, note_id_changed, .{
            .sample_rate = params.sample_rate,
            .attack = .{ .linear = 0.01 },
            .decay = .{ .linear = 0.1 },
            .release = .{ .linear = 0.15 },
            .sustain_volume = 0.5,
            .note_on = params.note_on,
        });
        zang.zero(span, temps[2]);
        zang.multiplyScalar(span, temps[2], temps[1], 0.25);
        zang.multiply(span, outputs[0], temps[0], temps[2]);
    }
};

pub const WaveBeginVoice = struct {
    pub const num_outputs = 1;
    pub const num_temps = 3;
    pub const Params = struct {
        sample_rate: f32,
    };
    pub const NoteParams = struct {
    };

    field0_WaveBeginInstrument: WaveBeginInstrument,
    tracker0: zang.Notes(_track_wave_begin.Params).NoteTracker,
    trigger0: zang.Trigger(_track_wave_begin.Params),

    pub fn init() WaveBeginVoice {
        return .{
            .field0_WaveBeginInstrument = WaveBeginInstrument.init(),
            .tracker0 = zang.Notes(_track_wave_begin.Params).NoteTracker.init(&_track_wave_begin.notes),
            .trigger0 = zang.Trigger(_track_wave_begin.Params).init(),
        };
    }

    pub fn paint(self: *WaveBeginVoice, span: zang.Span, outputs: [num_outputs][]f32, temps: [num_temps][]f32, note_id_changed: bool, params: Params) void {
        if (note_id_changed) {
            self.tracker0.reset();
            self.trigger0.reset();
        }
        const _iap0 = self.tracker0.consume(params.sample_rate / 8.0, span.end - span.start);
        var _ctr0 = self.trigger0.counter(span, _iap0);
        while (self.trigger0.next(&_ctr0)) |_result| {
            const _new_note = note_id_changed or _result.note_id_changed;
            self.field0_WaveBeginInstrument.paint(_result.span, .{outputs[0]}, .{temps[0], temps[1], temps[2]}, _new_note, .{
                .sample_rate = params.sample_rate,
                .freq = _result.params.freq,
                .note_on = _result.params.note_on,
            });
        }
    }
};

pub const AccelerateVoice = struct {
    pub const num_outputs = 1;
    pub const num_temps = 3;
    pub const Params = struct {
        sample_rate: f32,
        playback_speed: f32,
    };
    pub const NoteParams = struct {
        playback_speed: f32,
    };

    field0_WaveBeginInstrument: WaveBeginInstrument,
    tracker0: zang.Notes(_track_accelerate.Params).NoteTracker,
    trigger0: zang.Trigger(_track_accelerate.Params),

    pub fn init() AccelerateVoice {
        return .{
            .field0_WaveBeginInstrument = WaveBeginInstrument.init(),
            .tracker0 = zang.Notes(_track_accelerate.Params).NoteTracker.init(&_track_accelerate.notes),
            .trigger0 = zang.Trigger(_track_accelerate.Params).init(),
        };
    }

    pub fn paint(self: *AccelerateVoice, span: zang.Span, outputs: [num_outputs][]f32, temps: [num_temps][]f32, note_id_changed: bool, params: Params) void {
        const temp_float0 = 8.0 * params.playback_speed;
        if (note_id_changed) {
            self.tracker0.reset();
            self.trigger0.reset();
        }
        const _iap0 = self.tracker0.consume(params.sample_rate / temp_float0, span.end - span.start);
        var _ctr0 = self.trigger0.counter(span, _iap0);
        while (self.trigger0.next(&_ctr0)) |_result| {
            const _new_note = note_id_changed or _result.note_id_changed;
            const temp_float1 = _result.params.freq * params.playback_speed;
            self.field0_WaveBeginInstrument.paint(_result.span, .{outputs[0]}, .{temps[0], temps[1], temps[2]}, _new_note, .{
                .sample_rate = params.sample_rate,
                .freq = temp_float1,
                .note_on = _result.params.note_on,
            });
        }
    }
};

pub const CoinVoice = struct {
    pub const num_outputs = 1;
    pub const num_temps = 3;
    pub const Params = struct {
        sample_rate: f32,
        freq_mul: f32,
    };
    pub const NoteParams = struct {
        freq_mul: f32,
    };

    field0_PulseOsc: zang.PulseOsc,
    field1_Envelope: zang.Envelope,
    tracker0: zang.Notes(_track_coin.Params).NoteTracker,
    trigger0: zang.Trigger(_track_coin.Params),

    pub fn init() CoinVoice {
        return .{
            .field0_PulseOsc = zang.PulseOsc.init(),
            .field1_Envelope = zang.Envelope.init(),
            .tracker0 = zang.Notes(_track_coin.Params).NoteTracker.init(&_track_coin.notes),
            .trigger0 = zang.Trigger(_track_coin.Params).init(),
        };
    }

    pub fn paint(self: *CoinVoice, span: zang.Span, outputs: [num_outputs][]f32, temps: [num_temps][]f32, note_id_changed: bool, params: Params) void {
        if (note_id_changed) {
            self.tracker0.reset();
            self.trigger0.reset();
        }
        const _iap0 = self.tracker0.consume(params.sample_rate / 1.0, span.end - span.start);
        var _ctr0 = self.trigger0.counter(span, _iap0);
        while (self.trigger0.next(&_ctr0)) |_result| {
            const _new_note = note_id_changed or _result.note_id_changed;
            const temp_float0 = params.freq_mul * _result.params.freq;
            zang.zero(_result.span, temps[0]);
            self.field0_PulseOsc.paint(_result.span, .{temps[0]}, .{}, _new_note, .{
                .sample_rate = params.sample_rate,
                .freq = zang.constant(temp_float0),
                .color = 0.5,
            });
            zang.zero(_result.span, temps[1]);
            self.field1_Envelope.paint(_result.span, .{temps[1]}, .{}, _new_note, .{
                .sample_rate = params.sample_rate,
                .attack = .instantaneous,
                .decay = .instantaneous,
                .release = .{ .linear = 0.04 },
                .sustain_volume = 1.0,
                .note_on = _result.params.note_on,
            });
            zang.zero(_result.span, temps[2]);
            zang.multiplyScalar(_result.span, temps[2], temps[1], 0.25);
            zang.multiply(_result.span, outputs[0], temps[0], temps[2]);
        }
    }
};

pub const LaserVoice = struct {
    pub const num_outputs = 1;
    pub const num_temps = 3;
    pub const Params = struct {
        sample_rate: f32,
        freq_mul: f32,
        carrier_mul: f32,
        modulator_mul: f32,
        modulator_rad: f32,
    };
    pub const NoteParams = struct {
        freq_mul: f32,
        carrier_mul: f32,
        modulator_mul: f32,
        modulator_rad: f32,
    };

    field0_SineOsc: zang.SineOsc,
    field1_Curve: zang.Curve,
    field2_SineOsc: zang.SineOsc,
    field3_Curve: zang.Curve,
    field4_Curve: zang.Curve,

    pub fn init() LaserVoice {
        return .{
            .field0_SineOsc = zang.SineOsc.init(),
            .field1_Curve = zang.Curve.init(),
            .field2_SineOsc = zang.SineOsc.init(),
            .field3_Curve = zang.Curve.init(),
            .field4_Curve = zang.Curve.init(),
        };
    }

    pub fn paint(self: *LaserVoice, span: zang.Span, outputs: [num_outputs][]f32, temps: [num_temps][]f32, note_id_changed: bool, params: Params) void {
        zang.zero(span, temps[0]);
        self.field1_Curve.paint(span, .{temps[0]}, .{}, note_id_changed, .{
            .sample_rate = params.sample_rate,
            .function = .smoothstep,
            .curve = &_curve_laser_curve,
        });
        zang.zero(span, temps[1]);
        zang.multiplyScalar(span, temps[1], temps[0], params.freq_mul);
        zang.zero(span, temps[0]);
        zang.multiplyScalar(span, temps[0], temps[1], params.carrier_mul);
        zang.zero(span, temps[1]);
        self.field3_Curve.paint(span, .{temps[1]}, .{}, note_id_changed, .{
            .sample_rate = params.sample_rate,
            .function = .smoothstep,
            .curve = &_curve_laser_curve,
        });
        zang.zero(span, temps[2]);
        zang.multiplyScalar(span, temps[2], temps[1], params.freq_mul);
        zang.zero(span, temps[1]);
        zang.multiplyScalar(span, temps[1], temps[2], params.modulator_mul);
        zang.zero(span, temps[2]);
        self.field2_SineOsc.paint(span, .{temps[2]}, .{}, note_id_changed, .{
            .sample_rate = params.sample_rate,
            .freq = zang.buffer(temps[1]),
            .phase = zang.constant(0.0),
        });
        zang.zero(span, temps[1]);
        zang.multiplyScalar(span, temps[1], temps[2], params.modulator_rad);
        zang.zero(span, temps[2]);
        self.field0_SineOsc.paint(span, .{temps[2]}, .{}, note_id_changed, .{
            .sample_rate = params.sample_rate,
            .freq = zang.buffer(temps[0]),
            .phase = zang.buffer(temps[1]),
        });
        zang.zero(span, temps[0]);
        self.field4_Curve.paint(span, .{temps[0]}, .{}, note_id_changed, .{
            .sample_rate = params.sample_rate,
            .function = .smoothstep,
            .curve = &_curve_laser_volume,
        });
        zang.multiply(span, outputs[0], temps[2], temps[0]);
    }
};

pub const ExplosionVoice = struct {
    pub const num_outputs = 1;
    pub const num_temps = 4;
    pub const Params = struct {
        sample_rate: f32,
    };
    pub const NoteParams = struct {
    };

    field0_Curve: zang.Curve,
    field1_Filter: zang.Filter,
    field2_Noise: zang.Noise,
    field3_Curve: zang.Curve,

    pub fn init() ExplosionVoice {
        return .{
            .field0_Curve = zang.Curve.init(),
            .field1_Filter = zang.Filter.init(),
            .field2_Noise = zang.Noise.init(),
            .field3_Curve = zang.Curve.init(),
        };
    }

    pub fn paint(self: *ExplosionVoice, span: zang.Span, outputs: [num_outputs][]f32, temps: [num_temps][]f32, note_id_changed: bool, params: Params) void {
        zang.zero(span, temps[0]);
        self.field0_Curve.paint(span, .{temps[0]}, .{}, note_id_changed, .{
            .sample_rate = params.sample_rate,
            .function = .smoothstep,
            .curve = &_curve_explosion_cutoff,
        });
        zang.zero(span, temps[1]);
        zang.multiplyScalar(span, temps[1], temps[0], std.math.pi);
        {
            var i = span.start;
            while (i < span.end) : (i += 1) {
                temps[2][i] = temps[1][i] / params.sample_rate;
            }
        }
        {
            var i = span.start;
            while (i < span.end) : (i += 1) {
                temps[1][i] = std.math.cos(temps[2][i]);
            }
        }
        {
            var i = span.start;
            while (i < span.end) : (i += 1) {
                temps[2][i] = 1.0 - temps[1][i];
            }
        }
        zang.zero(span, temps[1]);
        zang.multiplyScalar(span, temps[1], temps[2], 2.0);
        {
            var i = span.start;
            while (i < span.end) : (i += 1) {
                temps[2][i] = std.math.min(1.0, temps[1][i]);
            }
        }
        {
            var i = span.start;
            while (i < span.end) : (i += 1) {
                temps[1][i] = std.math.max(0.0, temps[2][i]);
            }
        }
        {
            var i = span.start;
            while (i < span.end) : (i += 1) {
                temps[2][i] = std.math.sqrt(temps[1][i]);
            }
        }
        zang.zero(span, temps[1]);
        self.field2_Noise.paint(span, .{temps[1]}, .{}, note_id_changed, .{
            .color = .white,
        });
        zang.zero(span, temps[3]);
        self.field1_Filter.paint(span, .{temps[3]}, .{}, note_id_changed, .{
            .input = temps[1],
            .type = .low_pass,
            .cutoff = zang.buffer(temps[2]),
            .res = 0.0,
        });
        zang.zero(span, temps[1]);
        self.field3_Curve.paint(span, .{temps[1]}, .{}, note_id_changed, .{
            .sample_rate = params.sample_rate,
            .function = .smoothstep,
            .curve = &_curve_explosion_volume,
        });
        zang.multiply(span, outputs[0], temps[3], temps[1]);
    }
};
